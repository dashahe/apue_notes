# 进程控制

## 进程标识
每个进程都有一个`pid`。这个pid是唯一的，但是又是可复用的，所以一个进程终止后，会回收pid，然后为后面的进程来使用，当然，中间会间隔一段时间。

- pid为0的进程为 **调度进程(swapper)**，内核的一部分。
- pid为1的进程为init进程，是一个普通的用户进程，但是以超级用户特权运行，而且会成为所有孤儿进程的父进程。
- pid为2的进程是 **页守护进程(page daemon)**。

## fork(), vfork()函数
这两个函数都是用来创建子进程的。一般来说，创建子进程有两种不同的用途：
- 用来执行某个事件的处理，比如用多进程来实现并发的服务器。
- 另外一种，就是用`execve()`运行其他程序，典型的例子就是shell。

对于第一种用途，我们需要`fork()`函数带来的便利，因为子进程会copy父进程的data、stack和heap，只是共享text，这样就可以保证进程之间互相不干扰。但是，这样做的代价比较高，因为如果是用作第二种用途，根本就不需要这些信息，而`vfork()`就是用来满足这种需求，它不会完全copy父进程的地址空间。所以：
- vfork()不会完全copy父进程的地址空间，而fork()会拷贝很多东西
- vfork()保证子进程先运行，在vfork()调用了exec()或exit()后，父进程再恢复执行，否则堵塞。

另外值的注意的是，fork()函数虽然不会跟父进程共用地址空间，但是，文件是共享的，因为拷贝了父进程的文件描述符表，而这些文件描述符表项指向的文件表还是相同的，而这个文件表是同一个，也就是说，父进程打开的文件，在子进程中是共享的，这样可能导致冲突的产生。

## 孤儿进程和僵尸进程
#### 什么是孤儿进程？
每个进程都有一个父进程，如果一个父进程`fork()`出一个子进程，并且父进程在子进程终止之前就终止了，那么这个子进程就会变成孤儿进程，而这个孤儿进程会被init进程（pid为1）收养。

操作的过程大致是，一个进程终止时，内核检查所有活动进程，如果是正要终止进程的子进程，那么就将其父进程id设置为1。

#### 什么是僵尸进程？
内核为每个终止进程都保存了一定的信息，包括pid、终止状态、CPU时间总量等等，父进程调用wait或者waitpid可以获得这些信息。如果一个进程终止后，它并不会所有的东西都会被回收，只是释放存储区，关闭所有打开的文件。那么，这个时候这个终止了的进程就是僵尸进程。除非父进程wait取得了子进程的终止状态，那么子进程终止后会变成僵尸进程。

**那么，为了避免僵尸进程，父进程最好wait一下子进程。这个可以用信号来解决。**

## wait(), waitpid(), waitid(), wait3(), wait4()函数
当一个进程终止时，内核会向其父进程发送`SIGCHLD`信号。如果调用了wait或者waitpid，那么父进程会等待子进程，会一直堵塞，等待子进程终止。wait一定会堵塞，但是waitpid可以设置一个参数来不堵塞。

waitpid函数中pid参数：
- pid == -1，等待任何一个子进程终止
- pid > 0，等待指定子进程
- pid == 0，等待gid等于调用进程的gid的任何一个子进程
- pid < -1，等待gid等于pid绝对值的任何一个子进程

waitid类似于waitpid，但是通过增加一个参数，来实现明确的指定等待的是进程组还是进程。

wait3, wait4类似于上面几个wait，但是多了一个功能，就是可以获得终止进程以及其所有子进程的资源使用情况。

## race condition
竞争条件就是多个进程都企图对共享数据进行某种处理，那么最后的结果取决于进程的运行顺序。比如，一个无缓冲的输出，都共享一个文件，那么就需要父子进程沟通好，不然顺序就会乱套。

如果为了让进程保持某种顺序，比如让父进程先执行，可以这样：
```c
while (getppid() != 1) {
    sleep(1);
}
```
这种方式叫做 **轮询(polling)**，这样做比较浪费CPU资源。

为了让进程按照某种顺序，我们需要一种进程间通信(IPC)来实现。可以用信号机制来实现。

只需要能够实现TELLWAIT(设置wait)，TELL PARENT，TELL CHILD， WAIT PARENT， WAIT CHILD就可以了。这五种例程可以有多种实现方式。

## exec函数
这个函数不会创建一个新的进程，它不会改变pid，只是用一个新程序来替换了当前进程的text、data、heap和stack。

## system函数
这个函数用来执行某个命令。它实际上就相当于先fork了一个进程，然后exec调用了shell来执行命令，另外父进程会一直堵塞，等待system函数执行完。

## 进程调度、进程会计
调度策略和调度优先级都是内核确定的，进程可以通过nice()函数来设置nice值。nice值越高，那么优先级越低。
子进程会父进程的优先级。